# 归并排序
## 二路
```
function merge_sort(arr,l,r){
    // 只有一个元素了终止
    if(l>=r){return}
    let mid = (l+r)>>1
    merge_sort(arr,l,mid)
    merge_sort(arr,mid+1,r)
    // 合并
    let h = []
    let x = l
    let y = mid+1
    while(x<=mid||y<=r){
        // 如果右区间为空
        // 如果左区间不为空,且值小等于右
        if(y>r||x<=mid&&arr[x]<=arr[y]){
            h.push(arr[x])
            x++
        }else{
            h.push(arr[y])
            y++
        }
    }
    // 如果只是数组可以使用数组的splice替换排序之后的
    for(let i =l;i<=r;i++){
        arr[i]=h[i-l]
    }
}
```
  
## 题目来源[LeetCode](https://leetcode-cn.com/)
- 剑指 Offer 51： 数组中的逆序对
  - 合并算法 并的时候进行比肩判断是否符合要求
  - 符合就记录
    - 归并右边数组元素的时候，看下左边还有多少位，就是对应这个元素的逆序对数
  - 这个过程发生在合并排序的过程中
  - 所以排序不会对结果造成影响
- 23： 合并K个升序链表
  - 这里用了小顶堆+归并的并
- 148： 排序链表
- 1305： 两棵二叉搜索树中的所有元素
- 327： 区间和的个数
  - 区间和等于前缀和两项相减的值
  - 使用归并的时候左右区间是有序的
  - 如果两边是有序的就会很好处理
  - 排序只是位置发生了变化，但是还是分在两边，组合不变也就是不会影响前缀和相减求区间和是否满足要求的结果
  - 这题就是这个地方要想明白，不然就很难理解为啥要给前缀和排序
  - ``lower <= sum[j]-sum[i] <= upper``
- 315： 计算右侧小于当前元素的个数
  - 排序的时候大的放左边
  - 方便求右边小的元素数量
  - 需要处理下元数据的生成新的数组记录值和排序前的下标，方便计数
- 53： 最大子序和
  - 可以使用前缀和，但不是最好的解法
- 1508： 子数组和排序后的区间和
- 面试题 04.08： 首个共同祖先
- 1302： 层数最深叶子节点的和