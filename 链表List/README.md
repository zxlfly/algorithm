# 链表
若干个节点串成一串的数据结构。每个节点有两个区域，一个是数据域，另一个是指针域（指向下一个，可以不是一个）。
```
struct Node {
    Node(int data):data(data),next(NULL){}
    int data;
    Node *next;
}
int main(){
    Node *head = NULL;
    head = new Node(1);
    head->next = new Node(2);
    head->next->next = new Node(3);
    head->next->next->next = new Node(4);
    Npde *p =head;
    whild(p !=NULL){
        printf("%d->",p->data);
        p=p->next;
    }
    printf("\n");
    return 0;
}
```
```
int data[10];
int next[10];
void add(int ind,int p,int val){
    next[ind]=p;
    data[p]=val;
    return ;
}
int main(){
    //头结点3
    int head = 3;.
    //头结点值
    data[3]=0;
    //头结点指向5节点值为1
    add(3,5,1);
    add(5,2,2);
    add(2,7,3);
    add(7,9,100);
    int p =head;
    whild(p!=0){
        printf("%d->",data[p]);
        p=next[p]
    }
    printf("\n")
    return 0;
}
```
链表的实现方式不是唯一的。也不止上面的两种。
## 典型应用场景
- 操作系统内的动态内存分配
- LRU缓存淘汰算法（hash链表）
  
## 题目来源LeetCode
- 环形链表
  - **判断链表是否有环（141）**
    - 遍历链表，将值存在哈希表里面，有重复的就是的
    - 快慢指针
      - 当快指针的next节点为null，或者本身节点为null时，说明没有
      - 如果有环快慢指针一定会相遇
  - **找到起点（142）**
    - 假设块指针一次走2步，慢指针一次一步
    - 慢指针走过a距离到达起点，此时快指针走过2a的距离
    - 假设环剩余长度为x，那么环的长度就是a+x
    - 还需要走x步相遇
    - 此时指针走到了a+x位置，距离环起点a
    - 也就是说head到环起点的长度和相遇点到起点长度一样
    - 将一个指针放到head，将相同的指针放在相遇点，开始走，相遇的位置就是起始位置。（不同的指针也行）
  - **快乐数（202）**
    - 指的是一个数字通过变换规则若干次后能变成1就是快乐数
      - 值的每位数的平方和等于下一个数
      - 例如：19->82->68->100->1
      - 每种语言的的最大整数值可能不一样，但是这个链表的长度一定是有限个的，就是最大整数的每位数平方和，因为这个是最大数的平方和了，就算这个数之前的所有的数都出现了，也只能这么多个。
- **链表反转（206）**
  - 定义三个指针pre、cur、next
    - pre指向null
    - cur指向第一个
    - next指向cur所指向的下一个节点
    - 初始化完毕
  - 然后移动指针pre到指针cur所在的位置，移动cur到next所在的位置
    - pre指向的是反转的头节点
    - cur是未反转的头结点
    - next还是cur指向的下一个节点
    - 第一步的时候相当于pre指向了原来的第一个头结点并且这个这个节点指向了null，然后cur指向了原来的next，next再往后一位
    - 以此类推，最后就反转完成
  - 递归解法（*大佬是这么说的，如果递归这个看不明白，就是语言基础太弱了。。*）
    - 先判断头结点或者下一个节点不为空
      - 不然直接返回头结点即可
    - 记录下一个节点的地址z，然后递归调用（传入的节点为z），依次得到下一个节点x（函数最后return的值），这样每次递归就会得到一个z
      - 递归到最后一层的时候，由于是最后一个节点了，前面的判断无法通过直接返回，此时x是最后一个节点，z是倒数第二个节点
        - 把头节点的下一个节点指向z的下一个节点（x）
          - 就是把z指向了x
        - 头结点的下一个节点设置成传入的头结点
          - 就是把x指向了z
        - 原来的最后一个节点成了头结点
          - 原来是z->x
          - 现在是x->z
        - 上面说到的头结点不是指的源链表的头结点，而是每次传进来的z，相当于每次递归就是把传进来的节点和它的下一个节点反转
        - 递归反转还可以传一个参数进去控制反转头几个
          - 每次反转一次后就-1（每次递归的时候传入的数值-1），知道达到反转个数就直接返回
- **链表指定区间反转（92）**
  - 