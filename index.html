<script>
/**
 * @param {character[][]} board
 * @return {void} Do not return anything, modify board in-place instead.
 */
// 找到边界的O
// 与边界O相邻的O不会被包围
// 其他的全部是X
class Node{
    constructor(i,j){
        this.i=i
        this.j=j
    }
}
var solve = function (board) {
    let q = []
    let res = []
    let map = new Set()
    let n =board.length
    let m =board[0].length
    for(let i =0;i<n;i++){
        res.push([])
        for(let j =0;j<m;j++){
            res[i][j]="X"
            if(i==0||i==n-1||j==0||j==m-1){
                if(board[i][j]=="O"){
                    res[i][j]="O"
                    map.add(i*n+j)
                    q.push(new Node(i,j))
                }
            }
        }
    }
    let dir = [[0,-1],[0,1],[1,0],[-1,0]]
    while (q.length) {
        let cur = q.shift()
        for(let i=0;i<4;i++){
            let x = cur.i+dir[i][0]
            let y = cur.j+dir[i][1]
            if(x<0||x>=n||y<0||y>=m)continue
            if(map.has(x*n+y))continue
            if(board[x][y]=='X')continue
            q.push(new Node(x,y))
            res[x][y]="O"
            map.add(x*n+y)
            console.log(x,y);
        }
    }
    return res
};
console.log(solve([["X","X","X","X","X","X","X","X","X","X","X","X","X","X","X","X","X","X","X","X"],["X","X","X","X","X","X","X","X","X","O","O","O","X","X","X","X","X","X","X","X"],["X","X","X","X","X","O","O","O","X","O","X","O","X","X","X","X","X","X","X","X"],["X","X","X","X","X","O","X","O","X","O","X","O","O","O","X","X","X","X","X","X"],["X","X","X","X","X","O","X","O","O","O","X","X","X","X","X","X","X","X","X","X"],["X","X","X","X","X","O","X","X","X","X","X","X","X","X","X","X","X","X","X","X"]]));
</script>


