# 链表
若干个节点串成一串的数据结构。每个节点有两个区域，一个是数据域，另一个是指针域（指向下一个，可以不是一个）。

## 典型应用场景
- 操作系统内的动态内存分配
- LRU缓存淘汰算法（hash链表）
  
## 题目来源[LeetCode](https://leetcode-cn.com/)
- 环形链表
  - **判断链表是否有环（141）**
    - 遍历链表，将值存在哈希表里面，有重复的就是的
    - 快慢指针
      - 当快指针的next节点为null，或者本身节点为null时，说明没有
      - 如果有环快慢指针一定会相遇
  - **找到起点（142）**
    - 假设块指针一次走2步，慢指针一次一步
    - 慢指针走过a距离到达环起点，此时快指针走过2a的距离
    - 假设慢指针再走b步就会相遇，相遇位置距离环起点距离为c
    - 此时快慢指针各走过的距离
      - 慢：a+b
      - 块（可能在环里面不止一圈,假设为n圈）：a+n(b+c)+b
    - 所以2(a+b)=a+n(b+c)+b
      - a=nc+(n-1)b
      - 因为n是圈数，b+c就是一圈，所以不管n是几，a都等于c
    - 也就是说head到环起点的长度和相遇点到起点长度一样
    - 将一个慢指针放到head，将相同的指针放在相遇点，开始走，相遇的位置就是起始位置。
  - **快乐数（202）**
    - 指的是一个数字通过变换规则若干次后能变成1就是快乐数
      - 值的每位数的平方和等于下一个数
      - 例如：19->82->68->100->1
      - 每种语言的的最大整数值可能不一样，但是这个链表的长度一定是有限个的，就是最大整数的每位数平方和，因为这个是最大数的平方和了，就算这个数之前的所有的数都出现了，也只能这么多个。
      - 如果得到重复的值就说明有环不是快乐数
- **链表反转（206）**
  - 定义三个指针pre、cur、next
    - pre指向null
    - cur指向第一个
    - next指向cur所指向的下一个节点
    - 初始化完毕
    - 第一步获取next，然后cur指向pre（此时为null，后续为上一次反转的值），接着pre指向cur（到这里就是原来的头结点cur反转了），最后cur指向下一个待反转的头结点next
    - 以此类推，最后就反转完成
  - 递归解法
    - 先判断头结点或者下一个节点不为空
      - 不然直接返回头结点即可
    - 记录下一个节点的地址z，然后递归调用（传入的节点为z），依次得到下一个节点x（函数最后return的值），这样每次递归就会得到一个z
      - 递归到最后一层的时候，由于是最后一个节点了，前面的判断无法通过直接返回，此时x是最后一个节点，z是倒数第二个节点
        - 把头节点的下一个节点指向z的下一个节点（x）
          - 就是把z指向了x
        - 头结点的下一个节点设置成传入的头结点
          - 就是把x指向了z
        - 原来的最后一个节点成了头结点
          - 原来是z->x
          - 现在是x->z
        - 上面说到的头结点不是指的源链表的头结点，而是每次传进来的z，相当于每次递归就是把传进来的节点和它的下一个节点反转
        - 递归反转还可以传一个参数进去控制反转头几个
          - 每次反转一次后就-1（每次递归的时候传入的数值-1），知道达到反转个数就直接返回
- **链表指定区间反转（92）**
  - 可以利用上面的递归反转头几个节点的方法，先找到要反转的头在哪，然后反转指定个数即可。
  - 也可以使用指针的方式，找到其实位置，并且反转过程需要记录次数，够了就结束。
- **链表K个一组反转（25）**
  - 就是k个一起反转，然后后面的依次反转，如果最后剩余的小于k个就结束了。
  - 其实解法依旧可以用上面递归反转的方式，k个一反转。
  - 设置一个虚头p指向第一个节点，q为第一个节点
  - 反转之后q就是下一个反转节点的前一个节点
  - 也就是下一个p
  - 指针解法
  - 和之前反转的差不多，变换就是需要反转一段完成之后需要把pre的位置移动到上次反转的head处，因为位置倒过来了
- **旋转链表（61）**
  - 就是头结点变成尾节点了，原来的第二个节点变成头结点了，依次这么做
  - 第一步将尾节点和头结点连接起来，形成一个环
  - 然后原来尾节点往后走需要旋转的个数
  - 最后将新的尾节点指向null，就是断开环
  - 操作完成
  - 可以用链表长度取余需要旋转的步数，可以减少不必要的转圈
- **两两交换链表中的节点（24）**
  - 可以使用**链表K个一组反转**这题的解法将k改成2即可
  - 另一种解法
  - 创建一个虚拟的空节点T，指向链表的head
  - 再分别创建三个指针P-C-N，指向原链表的head，head.next和head.next.next
  - 接下来进行两两交换
  - 首先P指向N
  - 然后C指向P
  - 然后T指向C，这样第一步就完成了
  - 然后T移动到P
  - 然后P移动到N
  - 然后C移动到P后一位
  - 然后N要放在C的下一个
  - 移动完毕；按着上面移动指针的顺序无限循环
  - 接着第二轮，交换P指针和C指针的值
  - 接着交换P指针C指针的位置
  - 然后T指针到P的位置
  - 然后P指针到N的为值
  - 然后N往后移一位
  - P==null||p.next==null操作结束
  - 实际操作的时候可以不定义这么多指针
- **删除链表的单数第N个节点（19）**
  - 设置一个虚拟节点p指向头结点
  - 设置一个q节点等于head节点
  - q节点往后走N位
  - 然后两个节点同时往后走
  - 当q节点指向null的时候
  - p节点就是要删除节点的前一个节点
- **删除链表中的重复节点（83）**
  - 这道题的链表是有序的，重复是相邻的
  - 设置p指向head
  - 然后和下一个比较
  - 相同就删除下一个
  - 不相同就p指向下一个继续比较
- **删除排序链表中的重复节点（82）**
  - 和上面的题很像，只不过这个是不保留重复的全部删掉