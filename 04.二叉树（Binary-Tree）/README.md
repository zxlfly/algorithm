# 二叉树
每个节点子节点最多两个。有节点数-1条边  
度代表子节点数。  
n个节点的树有n-1条边  
n0+n1+n2(表示节点中每种度数的个数)=n1+2n2+1(对应的边数边数)  
n0=n2+1(结论)
**完全二叉树**：只有在最后一层的右侧缺少节点，其他层节点必须是满的   
- 如果编号i的节点（编号从0开始）
  - 左孩子为2*i+1
  - 右孩子为2*i+2
- 那么就可以使用连续空间存储（数组）
  - 不需要记录子节点的位置
**满二叉树**：只有度为0和2的节点
**完美二叉树**：每一层节点都满了  
**二叉搜索树**：左子树节点都要小于根，右节点相反  
树里面，节点代表集合，边代表关系。

## 生成二叉树
```
class Node{
    constructor(key){
        this.key=key
        this.left = null
        this.right=null
    }
}
class Binarytree{
    constructor(){
        this.root = null
    }
    insert(val){
        let newNode = new Node(val)
        if(this.root==null){
            this.root=newNode
        }else{
            this.insertNode(this.root,newNode)
        }
    }
    insertNode(root,node){
        if(root.key>node.key){
            if(root.left!=null){
                this.insertNode(root.left,node)
            }else{
                root.left=node
            }   
        }else{
            if(root.right!=null){
                this.insertNode(root.right,node)
            }else{
                root.right=node
            }
        }
    }
}
```
- 二叉树
  - 完全二叉树
    - 维护集合最值
      - 堆
      - 优先队列
  - 多叉树/森林
    - 字符串及其相关转换问题
      - 字典树
      - AC自动机
    - 连通性问题
      - 并查集
  - 二叉排序树
    - 语言标准库中重要的数据检索容器的底层实现
      - AVL树
      - 2-3树
      - 红黑树
    - 文件系统、数据库底层重要数据结构
      - B-树/B-树

## 设计/理解递归程序
- 数学归纳法
  - 结构归纳法
- 赋予递归函数一个明确的意义
- 思考边界条件
- 实现递归过程
### 二叉树前序遍历
- 函数意义：前序遍历以root为根节点的二叉树
- 边界条件：root为空时不需要遍历
- 递归程序：前序遍历左子树、右子树

## 题目来源[LeetCode](https://leetcode-cn.com/)下面的题目主要是为了锻炼递归思想，所以采用的解法以递归为主。
- 144:二叉树的前序遍历
- 589:N 叉树的前序遍历
- 226:翻转二叉树
- 剑指 Offer 32 - II:从上到下打印二叉树 II
- 107:二叉树的层序遍历 II
- 103:二叉树的锯齿形层序遍历
- 110:平衡二叉树
- 112:路径总和
- 105:从前序与中序遍历序列构造二叉树
- 222:完全二叉树的节点个数
- 剑指 Offer 54:二叉搜索树的第k大节点
- 剑指 Offer 26:树的子结构
- 662:二叉树最大宽度
  - 满二叉树如果我们把每层节点按顺序编号
  - root.left=2*root
  - root.right=2*root+1
- 968:监控二叉树
  - 尽量让叶子节点的父节点安装摄像头，这样的数量是最少的
    - 所以从下往上后续遍历
  - 判断的时候需要知道节点的状态
    - 0：无覆盖
    - 1：有摄像头
    - 2：有覆盖
    - 空节点的状态为2，因为这样就可以在子节点的父节点方摄像头，而不是子节点
    - 所以递归的终止条件就是遇到空节点，此时返回2
  - 如果左右孩子都有覆盖，那么父节点应该就是无覆盖的状态了（因为我们的遍历方式）
  - 如果左右节点至少一个无覆盖
    - 都无覆盖
    - 一个覆盖
    - 一个有摄像头
    - 由于有一个孩子节点没有覆盖，所以父节点需要摄像头
  - 如果左右节点至少有一个摄像头
    - 左节点有摄像头，右节点有覆盖
    - 右节点有摄像仪，左节点有覆盖
    - 都有摄像头
    - 那么此时父节点有覆盖
  - 如果头结点没有覆盖
    - 以上的可能都处理完了，递归结束，可能头结点无覆盖